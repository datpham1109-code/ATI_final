datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Assessment {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  bookName   String?
  imageCover String?
  name       String

  // for now just READING
  sectionType SectionType @default(READING)
  parts       Part[]
  questions   Question[]
}

enum SectionType {
  READING
  LISTENING
  WRITTING
  SPEAKING
}

model Part {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title       String
  description String

  assessmentId   Int
  assessment     Assessment      @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  questionGroups QuestionGroup[]
  passage        Passage?
  questions      Question[]
}

enum QuestionType {
  MULTIPLE_CHOICE
  MULTIPLE_CHOICE_MORE_ANSWERS
  SUMMARY_COMPLETION
  IDENTIFYING_INFORMATION
  NOTE_COMPLETION
}

model QuestionGroup {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title               String
  description         String?
  startQuestionNumber Int
  endQuestionNumber   Int
  type                QuestionType

  partId                 Int
  part                   Part                    @relation(fields: [partId], references: [id], onDelete: Cascade)
  questions              Question[]
  multipleChoiceArray    MultipleChoice[]
  summaryCompletion      SummaryCompletion?
  identifyingInformation IdentifyingInformation?
  noteCompletion         NoteCompletion?
}

model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  questionNumber Int

  multipleChoice             MultipleChoice?
  summaryCompletionItem      SummaryCompletionItem?
  identifyingInformationItem IdentifyingInformationItem?
  blank                      Blank?
  partId                     Int
  part                       Part                        @relation(fields: [partId], references: [id], onDelete: Cascade)
  assessmentId               Int
  assessment                 Assessment                  @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  questionGroupId            Int
  questionGroup              QuestionGroup               @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)

  @@unique([questionNumber, assessmentId])
}

model NoteCompletion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  paragraph String

  blanks          Blank[]
  questionGroupId Int           @unique
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

model Blank {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  expectedAnswer String
  explanation    String?

  questionId Int      @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  NoteCompletion   NoteCompletion? @relation(fields: [noteCompletionId], references: [id])
  noteCompletionId Int?
}

model MultipleChoiceExpectedAnswer {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  choiceId Int @unique

  multipleChoiceId Int
  multipleChoice   MultipleChoice @relation(fields: [multipleChoiceId], references: [id], onDelete: Cascade)
}

enum MultipleChoiceType {
  ONE_ANSWER
  MORE_ANSWERS
}

model MultipleChoice {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title           String
  explanation     String?
  type            MultipleChoiceType
  expectedAnswers MultipleChoiceExpectedAnswer[]

  questionId Int      @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  choices         Choice[]
  questionGroupId Int
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

model Choice {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  content String

  multipleChoiceId Int
  multipleChoice   MultipleChoice @relation(fields: [multipleChoiceId], references: [id], onDelete: Cascade)
}

model IdentifyingInformation {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  identifyingInformationItems IdentifyingInformationItem[]
  questionGroupId             Int                          @unique
  questionGroup               QuestionGroup                @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

enum IdentifyingInformationAnswer {
  TRUE
  FALSE
  NOT_GIVEN
}

model IdentifyingInformationItem {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title          String
  expectedAnswer IdentifyingInformationAnswer
  explanation    String?

  questionId Int      @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  identifyingInformationId Int
  identifyingInformation   IdentifyingInformation @relation(fields: [identifyingInformationId], references: [id], onDelete: Cascade)
}

model SummaryCompletion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title               String?
  description         String?
  paragraphWithBlanks String

  summaryCompletionItems SummaryCompletionItem[]
  questionGroupId        Int                     @unique
  questionGroup          QuestionGroup           @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

model SummaryCompletionItem {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  expectedAnswer String
  explanation    String?

  questionId Int      @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  summaryCompletionId Int
  summaryCompletion   SummaryCompletion @relation(fields: [summaryCompletionId], references: [id], onDelete: Cascade)
}

model Passage {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title       String
  description String?
  imageHeader String?
  content     String

  partId Int  @unique // Ensures that each Part can have only one Passage
  part   Part @relation(fields: [partId], references: [id], onDelete: Cascade)
}

enum UserRole {
  ADMIN
  USER
}

model User {
  id                 String    @id @default(cuid())
  name               String?
  email              String?   @unique
  emailVerified      DateTime?
  image              String?
  password           String?
  role               UserRole  @default(USER)
  isTwoFactorEnabled Boolean   @default(false)

  accounts              Account[]
  twoFactorConfirmation TwoFactorConfirmation?
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

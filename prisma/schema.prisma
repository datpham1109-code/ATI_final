datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Result {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  score               Float
  totalCorrectAnswers Int
  timeSpent           Int

  assessmentId String     @unique
  assessment   Assessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
}

model Assessment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  bookName       String?
  imageCover     String?
  name           String
  totalQuestions Int
  duration       Int
  isPublic       Boolean @default(false)

  // for now just READING
  sectionType SectionType @default(READING)
  questions   Question[]
  parts       Part[]
  result      Result?
}

enum SectionType {
  READING
  LISTENING
  WRITTING
  SPEAKING
}

model Part {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title       String
  description String
  order       Int

  questions      Question[]
  assessmentId   String
  assessment     Assessment      @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  questionGroups QuestionGroup[]
  passage        Passage?
}

enum QuestionType {
  MULTIPLE_CHOICE_ONE_ANSWER
  MULTIPLE_CHOICE_MORE_ANSWERS
  IDENTIFYING_INFORMATION
  COMPLETION
  TABLE_COMPLETION
  MATCHING
  MATCHING_HEADING
}

model QuestionGroup {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title               String
  description         String?
  startQuestionNumber Int
  endQuestionNumber   Int
  type                QuestionType

  partId    String
  part      Part       @relation(fields: [partId], references: [id], onDelete: Cascade)
  questions Question[]

  multiOneList     MultipleChoiceOneAnswer[]
  multiMoreList    MultipleChoiceMoreAnswers[]
  identifyInfoList IdentifyingInformation[]

  completion          Completion?
  matching            Matching?
  matchingChoiceGroup MatchingChoiceGroup?
  // matchingHeading     MatchingHeading?
}

model Question {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  questionNumber Int
  correctAnswer  String
  explain        String?
  respond        String?

  questionGroupId String
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
  partId          String
  part            Part          @relation(fields: [partId], references: [id])
  assessmentId    String
  assessment      Assessment    @relation(fields: [assessmentId], references: [id])

  completionId   String?
  completion     Completion?                @relation(fields: [completionId], references: [id])
  multiOne       MultipleChoiceOneAnswer?
  multiMore      MultipleChoiceMoreAnswers?
  matchingChoice MatchingChoice?
  identifyInfo   IdentifyingInformation?

  // passageMultiHeading PassageMultiHeading?
}

model MultipleChoiceOneAnswer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title String

  questionId      String        @unique
  question        Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionGroupId String
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
  choices         Choice[]
}

model MultipleChoiceMoreAnswers {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title           String
  explanation     String?
  expectedAnswers String[]

  questionId      String        @unique
  question        Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionGroupId String
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
  choices         Choice[]
}

model Choice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  content     String
  isCorrect   Boolean
  order       Int
  explanation String?

  multiOneId  String?
  multiOne    MultipleChoiceOneAnswer?   @relation(fields: [multiOneId], references: [id], onDelete: Cascade)
  multiMoreId String?
  multiMore   MultipleChoiceMoreAnswers? @relation(fields: [multiMoreId], references: [id], onDelete: Cascade)
}

enum IdentifyChoice {
  TRUE
  FALSE
  NOT_GIVEN
}

model IdentifyingInformation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title         String
  choiceCorrect IdentifyChoice

  questionId      String        @unique
  question        Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionGroupId String
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

model Completion {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  paragraph String

  questions       Question[]
  questionGroupId String        @unique
  questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

model Matching {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  paragraph String

  questionGroupId       String              @unique
  questionGroup         QuestionGroup       @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
  matchingChoiceGroupId String              @unique
  matchingChoiceGroup   MatchingChoiceGroup @relation(fields: [matchingChoiceGroupId], references: [id], onDelete: Cascade)
}

model MatchingChoiceGroup {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title String?

  matching           Matching?
  matchingChoiceList MatchingChoice[]
  questionGroupId    String           @unique
  questionGroup      QuestionGroup    @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
}

model MatchingChoice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  content String

  questionId            String?             @unique
  question              Question?           @relation(fields: [questionId], references: [id], onDelete: Cascade)
  matchingChoiceGroupId String
  matchingChoiceGroup   MatchingChoiceGroup @relation(fields: [matchingChoiceGroupId], references: [id], onDelete: Cascade)
}

// model MatchingHeading {
//   id        Int      @id @default(autoincrement())
//   createdAt DateTime @default(now())
//   updatedAt DateTime @default(now()) @updatedAt

//   title                    String
//   matchingHeadingItemArray MatchingHeadingItem[]
//   passageHeadingArray      PassageMultiHeading[]

//   questionGroupId String        @unique
//   questionGroup   QuestionGroup @relation(fields: [questionGroupId], references: [id], onDelete: Cascade)
// }

// model MatchingHeadingItem {
//   id        Int      @id @default(autoincrement())
//   createdAt DateTime @default(now())
//   updatedAt DateTime @default(now()) @updatedAt

//   content String

//   passageMultiHeadingId String?                 @unique
//   passageMultiHeading   PassageMultiHeading? @relation(fields: [passageMultiHeadingId], references: [id], onDelete: Cascade)

//   matchingHeadingId Int
//   matchingHeading   MatchingHeading @relation(fields: [matchingHeadingId], references: [id], onDelete: Cascade)
// }

enum PassageType {
  PASSAGE_SIMPLE
  PASSAGE_MULTI_HEADING
}

model PassageHeading {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title   String
  content String
  order   Int

  passageId String
  passage   Passage @relation(fields: [passageId], references: [id], onDelete: Cascade)

  // questionId          String?              @unique
  // question            Question?            @relation(fields: [questionId], references: [id], onDelete: Cascade)
  // matchingHeadingItem MatchingHeadingItem?
  // matchingHeadingId   Int?
  // matchingHeading     MatchingHeading?     @relation(fields: [matchingHeadingId], references: [id], onDelete: Cascade)
}

model Passage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  title       String
  description String?
  image       String?
  type        PassageType
  content     String?

  passageHeadingList PassageHeading[]
  partId             String           @unique
  part               Part             @relation(fields: [partId], references: [id], onDelete: Cascade)
}

enum UserRole {
  ADMIN
  USER
}

model User {
  id                 String    @id @default(cuid())
  name               String?
  email              String?   @unique
  emailVerified      DateTime?
  image              String?
  password           String?
  role               UserRole  @default(USER)
  isTwoFactorEnabled Boolean   @default(false)

  accounts              Account[]
  twoFactorConfirmation TwoFactorConfirmation?
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}
